# 操作系统



## 进程的状态

Linux进程的六种状态（R、S、D、T、Z、X） <https://blog.csdn.net/wjd_231/article/details/81432999>

R --- TASK_RUNNING（可执行状态）
S --- TASK_INTERRUPTIBLE（可中断的睡眠状态）
D --- TASK_UNINTERRUPTIBLE（不可中断的睡眠状态）(disk sleep)
T --- TASK_STOPPED或TASK_TRACED（暂停状态或跟踪状态）
Z --- TASK_DEAD - EXIT_ZOMBIE（退出状态，进程成为僵尸进程）
X --- TASK_DEAD - EXIT_DEAD（退出状态，进程即将被销毁）

* **TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的**。比如内核跟硬件交互的时候，为了避免进程与设备交互的过程被打断，造成设备陷入不可控的状态，可能就需要这种状态。

Linux 中的进程睡眠状态有两种：一种是可中断的睡眠状态，其状态标志位为TASK_INTERRUPTIBLE；另一种是不可中断的睡眠状态，其状态标志位为TASK_UNINTERRUPTIBLE。

可中断的睡眠状态的进程会睡眠直到某个条件变为真，如产生一个硬件中断、释放进程正在等待的系统资源或是传递一个信号都可以是唤醒进程的条件。

不可中断睡眠状态与可中断睡眠状态类似，但是它有一个例外，那就是把信号传递到这种睡眠状态的进程不能改变它的状态，也就是说它不响应信号的唤醒。

### 僵尸进程

D进程可以通过提供其需要的资源使其继续运行

僵尸进程 <https://www.cnblogs.com/chenjianhong/p/4144513.html> 该文十分搞笑

子进程死亡时，父进程没有回复。

解决方法：通知父进程该进程应当结束，或直接结束其父进程

## 内存相关

### 内存映射

tlb<https://zhuanlan.zhihu.com/p/108425561>

### 伙伴算法

伙伴算法https://blog.csdn.net/csdn_kou/article/details/82355452



## 进程，线程


线程/进程in linux<https://zhuanlan.zhihu.com/p/93553600>

Linux中创建进程一共有三个函数：fork，创建子进程 vfork，与fork类似，但是父子进程共享地址空间，而且子进程先于并阻塞父进程运行。 clone，主要用于创建线程。Linux中所有的进程创建都是基于复制的方式，Linux通过复制父进程来创建一个新进程,通过调用do_ fork来实现。然后对子进程做一些特殊的处理。

线程只是和父进程共享了打开的文件和文件系统信息，共享了地址空间和信号处理函数。本质上和进程没有区别

#### fork

子进程继承父进程<https://blog.csdn.net/ouyangjinbin/article/details/51107135>

父进程将成为fork之后优先调度的对象，但是没有保证父进程优先运行。

子进程 pcb 的页表指向与父进程相同的物理内存页，这样就只拷贝父进程的页表项即可，但这个时候内存中的所有内容都是只读的，如果父子进程都对内存进行只读操作，那么这个状态就可以一直保持下去，一旦有一方想要对内存进行写操作，就会引发缺页异常，此时，内核才会为子进程申请一个新的物理页，并将原物理页中的内容真正的复制到新的物理页中，让父子进程真正拥有各自的物理内存页，此时他们各自内存中的内容就是可写的了。



#### 进程调度



linux cfs调度<https://zhuanlan.zhihu.com/p/372441187>

CFS即Completely Fair Scheduler，顾名思义，完全公平调度器。

CFS作为主线调度器之一，也是最典型的O(1)调度器之一，在Linux2.6.23内核版本中引入，它最大的特点就是能保证任务调度的公平性。

CFS能在真实硬件上模拟出一种“**公平的、精确的任务多处理CPU**”。

1. CFS使用红黑树结构，来存储要调度的任务队列。

2. 每个节点代表了一个要调度的任务，节点的key即为虚拟时间（vruntime），虚拟时间由这个人物的运行时间计算而来。

3. key越小，也就是vruntime越小的话，红黑树对应的节点就越靠左。

4. **CFS scheduler每次都挑选最左边的节点作为下一个要运行的任务，**这个节点是“缓存的”——由一个特殊的指针指向；不需要进行O（logn）遍历来查找。也因此，CFS搜索的时间是O(1)。

vruntime += 实际运行时间（time process run) * 1024 / 进程权重

**CFS的唤醒抢占特性：**
休眠进程在唤醒时会获得vruntime的补偿，它在醒来的时候有能力抢占CPU是大概率事件，这也是CFS调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。新建的进程的vruntime是0，直接执行

CFS不能区分交互式进程和主动休眠的进程，主动休眠的进程并不要求快速响应，但也会在唤醒时获得补偿，例如通过调用sleep()、nanosleep()的方式，定时醒来完成特定任务，这有可能会导致其它更重要的应用进程被抢占，有损整体性能。

## 进程通信方式

1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
1. **有名管道(Names Pipes)** : **匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。**有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机**任意两个进程**通信。
1. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
1. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是**消息队列存放在内核**中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。**
1. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
1. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
1. **套接字(Sockets)** : 此方法主要用于在**客户端和服务器之间通过网络进行通信**。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

## 进程同步方式

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
1. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
1. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

## IO

linux有五种io实现：



### **阻塞式I/O**

在linux中，默认情况下，所有套接字都是阻塞的。 下面是阻塞套接字的recvfrom的的调用图：

![这里写图片描述](https://img-blog.csdn.net/20180630234416208?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### **非阻塞式I/O**

与阻塞式I/O不同的是，非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error（EAGAIN 或 EWOULDBLOCK）。进程在返回之后，可以处理其他的业务逻辑，过会儿再发起recvform系统调用。采用轮询的方式检查内核数据，直到数据准备好。再拷贝数据到进程，进行数据处理。

![这里写图片描述](https://img-blog.csdn.net/20180630234618392?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

优点：可以做点其他事情

缺点：响应延迟增大，吞吐降低

### **I/O复用（select，poll，epoll等）**

以select为例，当用户进程调用了select，那么整个进程会被阻塞，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程。

![这里写图片描述](https://img-blog.csdn.net/20180630234720199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

https://zhuanlan.zhihu.com/p/272891398

#### select

select本质上是通过设置或检查存放fd标志位的数据结构进行下一步处理。单个select能过够监视的端口数量有限，64位机默认2048个。

select对socket进行线性扫描，发生io事件时扫描所有端口。

#### poll

管理多个描述符也是进行轮询，根据描述符的状态进行处理，但**poll没有最大文件描述符数量的限制**，基于链表存储fd。

缺点：大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，依然需要轮询

#### epoll

epoll修改主动轮询为被动通知，主程序可以做其他事情，复杂度降到O(1)。回调机制负责进行通知

触发模式分为**EPOLLLT**和**EPOLLET**两种：

- LT，默认的模式（水平触发） 只要该fd还有数据可读，每次 `epoll_wait` 都会返回它的事件，提醒用户程序去操作，直到缓冲区为空；（有数据会连续触发）缺点：性能消耗大
- ET是“高速”模式（边缘触发）只有所监听的事件状态改变或者有事件发生时，epoll_wait才会被触发；（有数据只触发一次）缺点：需要程序逻辑保证数据完整

epoll_wait:

```c
int epoll_wait（int epfd，struct epoll_event * events， int maxevents，int timeout）;
```

timeout是最短的返回间隔时间。

优点：没有最大连接数量的限制，效率提升，只关心活跃的连接。利用mmap文件映射来加速与内核空间的消息传递

### **信号驱动式I/O（SIGIO）**

允许Socket进行信号驱动IO,并注册一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

![这里写图片描述](https://img-blog.csdn.net/20180630234803839?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### **异步I/O（POSIX的aio_系列函数）**

异步IO不是顺序执行。用户进程进行aio_read系统调用之后，就可以去处理其他的逻辑了，无论内核数据是否准备好，都会直接返回给用户进程，不会对进程造成阻塞。等到数据准备好了，内核直接复制数据到进程空间，然后从内核向进程发送通知，此时数据已经在用户空间了,可以对数据进行处理了。

![这里写图片描述](https://img-blog.csdn.net/20180630234859454?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
