# 零拷贝技术

https://blog.csdn.net/qq_40337086/article/details/113264601

## 传统io

![在这里插入图片描述](D:\study\lbeco\lbeco.github.io\pic\zero1)

进行四次切换，文件从磁盘拷到内核态缓冲区，再从内核态缓冲区拷到用户态，再从用户态拷到socket缓冲区，最后dma拷贝到网卡发出去

## 零拷贝技术1：mmap+write

mmap系统调用函数会直接把内核缓冲区里的数据共享到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。

![在这里插入图片描述](D:\study\lbeco\lbeco.github.io\\pic\zero2)

调用mmap后，DMA会把磁盘的数据拷贝刀缓冲区内，接着，应用和操作系统会共享这个缓冲区。

应用再调度write，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据。

最后，通过DMA直接将数据拷贝到网卡中。

这么做，可以减少一次数据拷贝，但是系统调用还是两次，依然需要4次上下文切换

## 零拷贝技术2：sendfile

在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile。

![在这里插入图片描述](D:\study\lbeco\lbeco.github.io\pic\zero3)

这玩意调用一次就可以完成cpu拷贝的操作，不需要调用两次系统调用。



从 Linux 内核 2.4 版本开始起，`sendfile() 系统调用`的过程发生了点变化。通过 DMA 将磁盘上的数据拷贝到内核缓冲区里。只将缓冲区描述符和数据长度传到 socket 缓冲区，而内核缓存中的数据则通过网卡的 SG-DMA 控制器直接拷贝到网卡的缓冲区里，这样就减少了一次数据拷贝



![在这里插入图片描述](D:\study\lbeco\lbeco.github.io\\pic\zero4)

sendfile第二版全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。

## PageCache

PageCache就是内核缓存区，由内存中的物理page组成，其内容对应磁盘上的block。其可以：

**1.缓存最近被访问的数据**

最近访问过的数据接下来很可能还会被访问，所以利用pagecache缓存，可以加速读取。空间不足时，会进行lru淘汰。

**2.预读功能**

利用空间局部性原理，将一部分空间内的数据读取到内存中

**3.IO优化**

内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「合并」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；

**PageCache不适合传输大文件**

每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。**其他「热点」的小文件可能就无法充分使用到 PageCache**，于是这样磁盘读写的性能就会下降了。费时费力利用DMA拷贝数据到PageCache中。

**大文件传输：异步IO+直接IO**

绕开 PageCache 的 I/O 叫直接 I/O，针对大文件应当使用异步IO加上直接IO来替代零拷贝技术。利用异步io可以执行其他任务。

![在这里插入图片描述](D:\study\lbeco\lbeco.github.io\\pic\zero5)