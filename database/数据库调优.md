# mysql数据库调优

## explain

![img](https://images2018.cnblogs.com/blog/512541/201808/512541-20180803142201303-545775900.png)

**概要描述：**

1. id:选择标识符

​	执行顺序

2. select_type:表示查询的类型。

3. table:输出结果集的表，单纯的表名

4. partitions:匹配的分区
5. **type**:表示表的连接类型

 	常用类型从左到右**ALL、index、range、 ref、eq_ref、const、system、NULL**。性能从低到高

​	**ALL** 全表扫描

​	**index** 索引全扫描

​	**range** 索引范围扫描

​	**ref** 使用非唯一索引扫描或唯一索引前缀扫描，**返回单条记录**，常出现在关联查询中，但一个表也行

​	**eq_ref** 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件。由于**独一无二**，所以速度较ref快

​	**const/system** 单条记录

​	**null** 不访问，直接返回

6. possible_keys:表示查询时，可能使用的索引

​	指出MySQL能使用哪个索引在表中找到记录

7. **key**:表示实际使用的索引，必然包含在possible_keys中

8. key_len:索引字段的长度

​	表示索引中使用的字节数

9. ref:列与索引的比较
10. **rows**:扫描出的行数(估算的行数)
11. filtered:按表条件过滤的行百分比
12. Extra:执行情况的描述和说明。会出现**Using filesort**表示在索引之外，需要额外进行外部的排序动作。导致该问题的原因一般和order by有者直接关系，一般可以通过合适的索引来减少或者避免。

## 三范式

**第一范式**

每列保持原子性

**第二范式**

确保表中的每列都和主键相关，而不是只和主键的某一部分相关（例如联合主键）

例如：订单编号和商品编号一起做为联合主键，然而表中存在商品信息这样与订单编号无关的列存在。

这种情况下，应当保证表被拆分开。

**第三范式**

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。