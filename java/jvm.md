# JVM

## JVM分区



![image-20220524011806937](D:\study\lbeco\lbeco.github.io\java\jvm.assets\image-20220524011806937.png)



### 程序计数器

字节码行号技术，执行naive方法时置空，唯一没有OutOfMemoryError的区域

### Java虚拟机栈

线程私有

### 本地方法栈

执行本地方法服务，也会跳出StackOverFlowError和OutOfMemoryError错误。

### Java堆

最主要的部分，需要垃圾回收。若超过内存，会抛出OutOfMemoryError

### 方法区

是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

当年HotSpot虚拟机直接使用永久区来实现方法区，这不是一个好主意，更加容易出现OutOfMemoryError。JDK8的时候HotSpot放弃永久代，改为将永久代全部移动到元空间中。会抛出OutOfMemoryError

**各版本实现**

方法区只是一个实现的接口，不同版本有不同的实现。

- 1.6 **永久代**来实现方法区，使用的是JVM的内存。
- 1.7 静态变量和字符串常量池转移到堆中。因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。
- 1.8 还在方法区里的元素转移到元空间，元空间存在本地内存里。这样做的好处是不会oom



![img](https://pic3.zhimg.com/80/v2-693f20f19b7a7a8d746c6fc34ea25810_1440w.jpg?source=1940ef5c)

6 7 8中方法的迁移

https://www.zhihu.com/question/23599282/answer/2423913695

### 运行时常量池

是方法区的一部分，保存常量

### 直接内存

在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。Netty中使用很多，会抛出OutOfMemoryError



## 垃圾回收

#### GCROOT对象

**虚拟机栈**中引用的对象

方法区中**类静态属性**引用的对象

方法区中**常量**引用的对象

在本地方法栈中**JNI（即通常所说的Native方法）引用的对象**

Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。

被同步锁（synchronized关键字）持有的对象。

#### **内存整理**

* 标记清除： 最基础的算法，内存碎片不管

* 标记整理：半区复制，一般用在新生代

* 标记复制：进行较多的复制操作，一般用在老年代

#### **三色标记**

基于可达性分析的 GC 算法，标记过程几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同，比如标记的方式有栈、队列、多色指针等。

### 分代思想

年轻代进入老年代的几种可能：

- 大对象直接进入老年代。

- 动态年龄判断

- 年龄大于阈值，进入老年代

- Minor GC后，存活的对象空间大于survivor空间，直接进入老年代。

**动态年龄判断**

年龄1+年龄2+年龄3+年龄N的对象加起来的空间，大于survivor区域的一半，就会让年龄N和年龄N以上的对象进入老年代。这样回收以后剩下的就不超过survivor区域的一半了。

##### 空间分配担保

空间分配担保能避免GC过于频繁，但是容易炸。故：

JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC

### 垃圾回收算法

<img src="D:\study\lbeco\lbeco.github.io\java\jvm.assets\image-20220524225149598.png" alt="image-20220524225149598" style="zoom: 50%;" />

**新生代**

---

#### Serial

单线程收集，简单粗暴

#### ParNew

是Serial的多线程并发版本，1.8时ParNew+CMS是官方推荐的选择

#### Parallel Scavenge

该垃圾收集器的目标是达到一个可控制的吞吐量（用于运行用户代码的时间与处理器总消耗时间的比值）

可以配置MaxGCPauseMillis控制最大垃圾收集停顿时间，和GCTimeRatio控制吞吐量大小

**老年代**

---

#### Serial Old

单线程收集

#### Parallel Old

多线程收集，JDK6才出现，处理器资源较为稀缺时可以考虑Parallel Scavenge加Parallel Old组合

#### CMS

整个过程分为

初始标记（CMS initial mark）会Stop The World, 会初步标记GC能直接标记到的对象

并发标记（CMS concurrent mark）不会停止线程，会并发标记直接的关联对象

重新标记（CMS remark）进行增量更新，会Stop The World，时间稍长

并发清除（CMS concurrent sweep）不需要停止线程，直接删除死亡对象

由于最耗时的阶段都不会停止用户线程，所以性能较好

跨代引用：

并不是所有老年代的对象都会引用着新生代的对象。那么相对频繁的YongGC，每次都从根节点遍历一次，效率就会被严重影响。

因此，就引入了卡表和记忆集的概念。卡表将整个老年代分成了多个层级，card[0],card[1],card[2]......。如果某个card区域中的老年代对象引用着新生代的对象，那么就被叫做脏卡。我们在每个新生代对象中存入一个RSet记录卡表。在检索新生代引用即将跨代时，会根据卡表的Key，Value快速定位到正确的老年代引用，以达到减少开销的目的。

#### **G1**

连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以 根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。可以设置目标停顿时间

对于跨Region引用，使用记忆集避免全堆扫描。记忆集每个Region存储自己被指向和指向别人。记忆集会占用一部分内存。类似跨代引用

#### **ZGC**

从JDK11开始出现，也采用基于Region的堆内存布局。Region分为不同大小容量

染色指针：直接把标记信息记在引用对象的指针上。通过标志位，可以直接从指针看到其引用对象的三色状态。染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉。

## 类加载机制

加载、链接、初始化

链接分为三个部分

加载、验证、准备、解析、初始化

### **加载**

将 Java 类的字节码文件加载到机器内存中。JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。创建的类是 java.lang.Class

### **验证**

**文件格式验证**，验证文件名，常量类型，符号是否正确等。完成这一流程后，字节流进入方法区存储。

**元数据验证**

对源码语义分析，验证的是子类继承的父类是否是final类；如果这个类的父类是抽象类，是否实现了其父类或接口中要求实现的所有方法；子父类中的字段、方法是否产生冲突等，这个过程把类、字段和方法看做组成类的一个个元数据，然后根据JVM规范，对这些元数据之间的关系进行验证。所以，元数据验证阶段并未深入到方法体内。

**字节码验证**

深入到方法内部验证代码时候正确，类型是否统一。无法保证一定正确

**符号引用验证**

判断可访问性（private public等）

### 准备

为 static 变量分配空间，设置默认值

### 解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程

1. 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可
2. 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄

符号引用与虚拟机实现的内存布局无关，直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。

### 初始化

初始化即调用 `< cinit >()V` 方法，虚拟机会保证这个类的 【构造方法】的线程安全



## 引用

### 强引用

最普通的引用。把一个对象赋给一个引用变量，这个引用变量就是一个强引用。一言以蔽之，打死不回收

### 软引用

java.lang.ref.SoftReference

软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。

软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收。

例子：Mybatis 缓存类 SoftCache 

caffeine也使用软引用或者弱引用

### 弱引用

java.lang.ref.WeakReference

弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

例子：ThreadLocal

### 虚引用

```java
WeakReference<Object> m = new WeakReference();
System.out.println(m.get());
```

虚引用的`m.get()`永远无法得到对象，永远都是null。
用途： 虚引用的唯一作用是管理堆外内存，因为JVM无法直接清理堆外内存，所以提供一个虚引用，交给垃圾回收器的回收队列，这个队列就是用来标记哪些堆外内存需要回收，再调用c++释放空间。

## JIT技术

JIt会编译那些频繁运行的代码为机器码

HotSpot虚拟机中使用基于计数器的热点探测方法**，**因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。

**方法内联** 

方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。JVM 会自动识别热点方法，并对它们使用方法内联进行优化。

**逃逸分析**

通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。如果外面没有引用，那就直接在栈上面分配就完事了。

**标量替换**

在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

