## java代理：



#### JDK动态代理

jdk动态代理是java原生的代理方式，

实现步骤如下：

1. 定义一个接口及其实现类；
2. 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；

**JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类**。之所以 JDK 的动态代理只能通过接口实现，原因是因为运行时 newProxyInstance 内部会缓存形式先通过字节码生成一个代理类，这个代理类默认已经继承了 Proxy 类，同时实现了我们传入的一堆接口；由于 Java 是单继承的，所以 JDK 动态代理只能代理接口，接口可以实现多个，但是类只能继承实现一个。

#### CGLIB 动态代理机制

CGLIB 动态代理使用字节码处理框架ASM，来转换字节码并生成新的类。通过生成一个被代理类的子类来拦截被代理类的方法调用

实现步骤如下：

1. 定义一个类；
2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
3. 通过 `Enhancer` 类的 `create()`创建代理类；



 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。